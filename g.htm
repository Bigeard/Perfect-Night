<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Perfect Night - Mobile Gamepad</title>
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no" />

    <!-- Apple WebApp -->
    <meta name="apple-mobile-web-app-title" content="Perfect Night" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#e4e4e4" />
    <link rel="apple-touch-icon" href="/favicon.ico">

    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="gamepad_resources/style.css">

    <!-- <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script> -->
    <script src="js/peerjs.min.js"></script>
    <script src="js/nipplejs.min.js"></script>
</head>

<body id="body">
    <div id="infoContainer">
        <div class="connectionStatus">
            <span>Status: <span id="status"></span></span><br>
            <span id="ping">Ping: X</span>
        </div>
        <div class="menuGame">
            <span>Menu</span>
        </div>
    </div>

    <div id="scrollDown">
        <span class="scrollDownText">Scroll down</span><br>
        <img class="scrollDownArrow" src="gamepad_resources/images/scroll_down.gif" alt="Scroll Down Gif">
    </div>

    <div id="infoTop">
        <span id="playerId" onclick="playerIdClick">PLAYER X</span>
    </div>

    <div id="infoLeft">
        <span id="playerLife">Life X</span>
    </div>

    <div id="infoRight">
        <span id="playerAmmunition">Ammo. X</span>
    </div>

    <div id="joysticks" class="controlInfo">
        <div id="joystickLeft"></div>
        <div id="joystickRight"></div>
    </div>

    <div id="rotatePhone"></div>

    <script type="text/javascript">
        // IOS disable zoom page
        const isIOS = /iPad|iPhone|iPod|Safari/.test(navigator.userAgent);
        if (isIOS) {
            document.addEventListener("touchend", (event) => {
                if (event.target.localName != "input") {
                    event.preventDefault();
                }
            }, { passive: false });
            document.addEventListener("gesturestart", (e) => {
                e.preventDefault();
            });

            document.addEventListener("gesturechange", (e) => {
                e.preventDefault();
            });
            document.addEventListener("gestureend", (e) => {
                e.preventDefault();
            });
        }

        // NippleJS - Joystick
        var joysticks = document.getElementById("joysticks");

        var joystickLeft = nipplejs.create({
            zone: document.getElementById("joystickLeft"),
            mode: "static",
            position: { left: "50%", top: "50%" },
            color: "grey",
            size: 185
        });

        var joystickRight = nipplejs.create({
            zone: document.getElementById("joystickRight"),
            mode: "static",
            position: { right: "50%", top: "50%" },
            color: "grey",
            size: 185
        });

        joystickLeft[0].resetDirection = function () {
            this.direction = {
                x: false,
                y: false,
                angle: false
            };
            this.frontPosition.x = 0;
            this.frontPosition.y = 0;
        };

        joystickRight[0].resetDirection = function () {
            this.direction = {
                x: false,
                y: false,
                angle: false
            };
            this.frontPosition.x = 0;
            this.frontPosition.y = 0;
        };

        // Display none scroll down indicator
        document.addEventListener("scroll", () => {
            if (joysticks.offsetHeight + joysticks.scrollTop >= joysticks.scrollHeight) {
                scrollDown.style.display = "none";
            }
        });

        // Display / Disable control information
        const controlInfo = localStorage.getItem("controlInfo");
        if (controlInfo) {
            joysticks.classList.remove("controlInfo");
        } else {
            localStorage.setItem("controlInfo", true);
        }

        var conn = null;
        var peer = {};

        // PeerJS - Communication with main screen
        (() => {
            var PeerPlayerId = false;
            var lastPeerId = null;
            var status = document.getElementById("status");
            var ping = document.getElementById("ping");
            var infoContainer = document.getElementById("infoContainer");
            var infoBottom = document.getElementById("infoBottom");
            var playerId = document.getElementById("playerId");
            var playerLife = document.getElementById("playerLife");
            var playerAmmunition = document.getElementById("playerAmmunition");

            var lastPing = 0;

            const init = () => {
                status.innerText = "No connection";

                const Config = {
                    //// ONLINE
                    secure: true,
                    host: "perfect-night-374900.oa.r.appspot.com",
                    port: 443,

                    //// LOCAL
                    // secure: false,
                    // host: "192.168.12.1",
                    // port: 9000,

                    path: "/peer",
                    iceServers: [
                        {
                            urls: [
                                //// ONLINE
                                "stun:stun3.l.google.com:19302",
                                "stun:stun4.l.google.com:19302",

                                //// LOCAL
                                // "192.168.12.1:5349"
                            ]
                        },
                        // { urls: [
                        //         "turn:eu-0.turn.peerjs.com:3478",
                        //         // "turn:us-0.turn.peerjs.com:3478", 
                        //     ],
                        //     username: "peerjs",
                        //     credential: "peerjsp"
                        // }
                    ],
                    debug: 2
                };
                peer = new Peer(Config);

                peer.on("open", (NewPeerPlayerId) => {
                    console.info("Peer Player (Client) Id:", NewPeerPlayerId);
                    if (peer.id === null) {
                        peer.id = lastPeerId;
                        console.info("Received null id from peer open");
                    } else {
                        lastPeerId = peer.id;
                    }

                    // Find Peer Server Id (in URL)
                    const params = new URLSearchParams(document.location.search);
                    let PeerServerId = params.get("i");
                    console.info("Peer Server (Main) Id:", PeerServerId);

                    // Manage Peer Player Id to reconnect easily
                    const peerConnection = JSON.parse(localStorage.getItem("peerConnection"));
                    if (peerConnection?.PeerServerId === PeerServerId) {
                        PeerPlayerId = peerConnection.PeerPlayerId
                    }
                    // @DEV_MODE
                    // if (!PeerPlayerId) {
                    //     // Store connection player
                    //     localStorage.setItem("peerConnection", JSON.stringify({
                    //         PeerServerId,
                    //         PeerPlayerId: NewPeerPlayerId
                    //     }));
                    // }

                    // Join the connection
                    if (PeerServerId) {
                        join(PeerServerId);
                    } else {
                        console.error("No ID - PeerServerId:", PeerServerId);
                    }
                });

                peer.on("connection", (c) => {
                    c.on("open", () => {
                        c.send("Sender does not accept incoming connections");
                        setTimeout(() => c.close(), 500);
                    });
                });

                peer.on("disconnected", () => {
                    status.innerText = "Connection lost. Please reconnect (disconnected)";
                    peer.id = lastPeerId;
                    peer._lastServerId = lastPeerId;
                    peer.reconnect();
                });

                peer.on("disconnect", () => {
                    status.innerText = "Connection lost. Please reconnect (disconnect)";
                    peer.id = lastPeerId;
                    peer._lastServerId = lastPeerId;
                    peer.reconnect();
                });

                peer.on("close", () => {
                    status.innerText = "Connection lost. Please reconnect (close)";
                    peer.id = lastPeerId;
                    peer._lastServerId = lastPeerId;
                    peer.reconnect();
                });

                peer.on("error", (err) => {
                    console.error(err);
                });
            };

            const join = (PeerServerId) => {
                if (conn) {
                    conn.close();
                }
                conn = peer.connect(PeerServerId, {
                    metadata: {
                        id: PeerPlayerId,
                    },
                    reliable: true,
                });
                conn.on("open", () => {
                    status.innerText = "Connected";
                    conn.send({ e: 1 }) // Get last edit
                    console.info("Connected to ", conn.peer)
                });
                conn.on("data", (data) => {
                    if (data != null && (typeof data === "object" || typeof data === "function")) {
                        if (data.color != null) {
                            joystickLeft[0].options.color = data.color;
                            joystickLeft[0].ui.front.style.background = data.color;
                            joystickLeft[0].ui.back.style.background = data.color;

                            joystickRight[0].options.color = data.color;
                            joystickRight[0].ui.front.style.background = data.color;
                            joystickRight[0].ui.back.style.background = data.color;

                            infoContainer.style.background = data.color;
                            infoTop.style.background = data.color;
                            infoLeft.style.background = data.color;
                            infoRight.style.background = data.color;
                            scrollDown.style.background = data.color;
                        }
                        if (data.index != null) {
                            playerId.innerText = "PLAYER " + data.index;
                        }
                        if (data.life != null || data.life === 0) {
                            playerLife.innerText = "Life " + data.life;
                            if (data.life <= 0) {
                                joysticks.classList.add("deadBackground");
                            }
                            else {
                                joysticks.classList.remove("deadBackground");
                            }
                        }
                        if (data.ammunition != null || data.ammunition === 0) {
                            playerAmmunition.innerText = "Ammu. " + data.ammunition;
                        }
                        ping.innerText = "Ping: " + (new Date().getTime() - data.t);
                        lastPing = data.t;
                    }
                    else {
                        console.info("Peer:", data);
                    }
                });
                conn.on("disconnected", () => {
                    peer.reconnect();
                    status.innerText = "Connection disconnected (conn.on(disconnected))";
                });
                conn.on("disconnect", () => {
                    peer.reconnect();
                    status.innerText = "Connection disconnect (conn.on(disconnect))";
                });
                conn.on("close", () => {
                    peer.reconnect();
                    status.innerText = "Connection closed (conn.on(close))";
                });
            };

            const signal = (sigName) => {
                if (conn && conn.open) {
                    conn.send(sigName);
                    console.info(sigName, "signal sent");
                } else {
                    console.info("Connection is closed");
                }
            }

            const loop = (timestamp) => {
                if (lastPing != 0 && new Date().getTime() - lastPing > 3000) {
                    lastPing = 0;
                    peer.disconnect();
                    conn = peer.connect(conn.peer, { reliable: true });
                }
                if (joystickLeft && joystickRight && peer.id && conn) {
                    conn.send({
                        t: new Date().getTime(), // Time
                        lx: (Math.round(joystickLeft[0].frontPosition.x) / 50),
                        ly: (Math.round(joystickLeft[0].frontPosition.y) / 50),
                        rx: (Math.round(joystickRight[0].frontPosition.x) / 50),
                        ry: (Math.round(joystickRight[0].frontPosition.y) / 50)
                    })
                }
                window.requestAnimationFrame(loop)
            }
            window.requestAnimationFrame(loop)
            init();
        })();
    </script>
</body>

</html>